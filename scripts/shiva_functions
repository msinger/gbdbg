SHIVA_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" >/dev/null && pwd)

SYSRAM_START=$(( 0x0000 ))
DUTRAM_START=$(( 0x1000 ))
RECRAM_START=$(( 0x2000 ))
SYSRAM_LEN=$(( 4096 ))
DUTRAM_LEN=$(( 4096 ))
RECRAM_LEN=$(( 4096 ))
SYSRAM_END=$(( SYSRAM_START + SYSRAM_LEN - 1 ))
DUTRAM_END=$(( DUTRAM_START + DUTRAM_LEN - 1 ))
RECRAM_END=$(( RECRAM_START + RECRAM_LEN - 1 ))

NUM_BREAKPOINTS=4

LED0=$(( 0xff00 ))
LED1=$(( 0xff01 ))

SW0=$(( 0xff02 ))
SW1=$(( 0xff03 ))

ATOM0=$(( 0xff10 ))
ATOM1=$(( 0xff11 ))
ATOM2=$(( 0xff12 ))
ATOM3=$(( 0xff13 ))

ONES=$(( 0xff14 ))

REC_CTRL=$(( 0xff15 ))
REC_CTRL_SET_START=$((  1 << 0 ))
REC_CTRL_SET_STOP=$((   1 << 1 ))
REC_CTRL_SET_RECORD=$(( 1 << 2 ))
REC_CTRL_START=$((      1 << 3 ))
REC_CTRL_STOP=$((       1 << 4 ))
REC_CTRL_RECORD=$((     1 << 5 ))
REC_CTRL_SET_ADR=$((    1 << 7 ))
REC_CFG=$(( 0xff16 ))
REC_CFG_CYCLIC=$(( 1 << 0 ))

NUM_COUNTERS=1
COUNTER_BASE=( $((0xff20)) $((0xff24)) )
COUNTER_COUNT_OFFSET=0
COUNTER_CTRL_OFFSET=0
COUNTER_SETCMP_OFFSET=1
COUNTER_SETIN_OFFSET=2
COUNTER_SETOUT_OFFSET=3
for i in ${!COUNTER_BASE[@]}; do
	(( COUNTER_COUNT0[i] = COUNTER_BASE[i] + COUNTER_COUNT_OFFSET     ))
	(( COUNTER_COUNT1[i] = COUNTER_BASE[i] + COUNTER_COUNT_OFFSET + 1 ))
	(( COUNTER_COUNT2[i] = COUNTER_BASE[i] + COUNTER_COUNT_OFFSET + 2 ))
	(( COUNTER_COUNT3[i] = COUNTER_BASE[i] + COUNTER_COUNT_OFFSET + 3 ))
	(( COUNTER_CTRL[i]   = COUNTER_BASE[i] + COUNTER_CTRL_OFFSET      ))
	(( COUNTER_SETCMP[i] = COUNTER_BASE[i] + COUNTER_SETCMP_OFFSET    ))
	(( COUNTER_SETIN[i]  = COUNTER_BASE[i] + COUNTER_SETIN_OFFSET     ))
	(( COUNTER_SETOUT[i] = COUNTER_BASE[i] + COUNTER_SETOUT_OFFSET    ))
done
COUNTER_CTRL_START=$((   1 << 0 ))
COUNTER_CTRL_STOP=$((    1 << 1 ))
COUNTER_CTRL_RESET=$((   1 << 2 ))
COUNTER_CTRL_LOAD=$((    1 << 3 ))
COUNTER_CTRL_COUNT=$((   1 << 4 ))
COUNTER_CTRL_SETLOAD=$(( 1 << 7 ))
COUNTER_SETIN_START=$((  1 << 0 ))
COUNTER_SETIN_STOP=$((   1 << 1 ))
COUNTER_SETIN_RESET=$((  1 << 2 ))
COUNTER_SETIN_LOAD=$((   1 << 3 ))
COUNTER_SETIN_COUNT=$((  1 << 4 ))

PA_OUT=$((       0xff40 ))
PA_SET=$((       0xff40 ))
PA_IN=$((        0xff41 ))
PA_RESET=$((     0xff41 ))
PA_SETTRIG=$((   0xff42 ))
PA_RESETTRIG=$(( 0xff43 ))

DUT_CTRL=$((     0xff50 ))
DUT_ADR_IN0=$((  0xff50 ))
DUT_ADR_IN1=$((  0xff51 ))
DUT_DATA_IN=$((  0xff52 ))
DUT_DATA_OUT=$(( 0xff52 ))
DUT_IN=$((       0xff53 ))
DUT_IN_DATA_DIR_OUT_POS=$(( 0 ))
DUT_IN_CS_RAM_POS=$((       1 ))
DUT_IN_RD_POS=$((           2 ))
DUT_IN_WR_POS=$((           3 ))
DUT_IN_PHI_POS=$((          4 ))
DUT_IN_RST_POS=$((          5 ))
DUT_IN_PA0_POS=$((          6 ))
DUT_CMP_OUT=$((  0xff51 ))
DUT_CMP_IN=$((   0xff53 ))
DUT_CTRL_SET_RESET=$((   1 << 0 ))
DUT_CTRL_SET_DATA=$((    1 << 1 ))
DUT_CTRL_RESET_RESET=$(( 1 << 2 ))
DUT_CTRL_RESET_DATA=$((  1 << 3 ))
DUT_CMP_OUT_MATCH0=$((   1 << 0 ))
DUT_CMP_OUT_MATCH1=$((   1 << 1 ))
DUT_CMP_OUT_MATCH2=$((   1 << 2 ))
DUT_CMP_OUT_MATCH3=$((   1 << 3 ))
DUT_CMP_OUT_EDGE0=$((    1 << 4 ))
DUT_CMP_OUT_EDGE1=$((    1 << 5 ))
DUT_CMP_OUT_EDGE2=$((    1 << 6 ))
DUT_CMP_OUT_EDGE3=$((    1 << 7 ))
DUT_CMP_IN_VAL0=$((      1 << 0 ))
DUT_CMP_IN_VAL1=$((      1 << 1 ))
DUT_CMP_IN_VAL2=$((      1 << 2 ))
DUT_CMP_IN_VAL3=$((      1 << 3 ))
DUT_CMP_IN_MASK0=$((     1 << 4 ))
DUT_CMP_IN_MASK1=$((     1 << 5 ))
DUT_CMP_IN_MASK2=$((     1 << 6 ))
DUT_CMP_IN_MASK3=$((     1 << 7 ))
DUT_BIT_ADR_SHIFT=0
DUT_BIT_ADR_MASK=$((     0x7fff << 0 ))
DUT_BIT_ADR0=$((         1 << 0 ))
DUT_BIT_ADR1=$((         1 << 1 ))
DUT_BIT_ADR2=$((         1 << 2 ))
DUT_BIT_ADR3=$((         1 << 3 ))
DUT_BIT_ADR4=$((         1 << 4 ))
DUT_BIT_ADR5=$((         1 << 5 ))
DUT_BIT_ADR6=$((         1 << 6 ))
DUT_BIT_ADR7=$((         1 << 7 ))
DUT_BIT_ADR8=$((         1 << 8 ))
DUT_BIT_ADR9=$((         1 << 9 ))
DUT_BIT_ADR10=$((        1 << 10 ))
DUT_BIT_ADR11=$((        1 << 11 ))
DUT_BIT_ADR12=$((        1 << 12 ))
DUT_BIT_ADR13=$((        1 << 13 ))
DUT_BIT_ADR14=$((        1 << 14 ))
DUT_BIT_CS_ROM=$((       1 << 15 ))
DUT_BIT_DATA_SHIFT=16
DUT_BIT_DATA_MASK=$((    0xff << 16 ))
DUT_BIT_DATA0=$((        1 << 16 ))
DUT_BIT_DATA1=$((        1 << 17 ))
DUT_BIT_DATA2=$((        1 << 18 ))
DUT_BIT_DATA3=$((        1 << 19 ))
DUT_BIT_DATA4=$((        1 << 20 ))
DUT_BIT_DATA5=$((        1 << 21 ))
DUT_BIT_DATA6=$((        1 << 22 ))
DUT_BIT_DATA7=$((        1 << 23 ))
DUT_BIT_DATA_DIR_OUT=$(( 1 << 24 ))
DUT_BIT_CS_RAM=$((       1 << 25 ))
DUT_BIT_RD=$((           1 << 26 ))
DUT_BIT_WR=$((           1 << 27 ))
DUT_BIT_PHI=$((          1 << 28 ))
DUT_BIT_RST=$((          1 << 29 ))
DUT_BIT_PA0=$((          1 << 30 ))

IFLAG=$(( 0xfffe ))
IEN=$((   0xffff ))

CGB_INCOMPATIBLE=
CGB_COMPATIBLE=$'\x80'
CGB_EXCLUSIVE=$'\xc0'

SGB_INCOMPATIBLE=
SGB_COMPATIBLE=$'\x03'

CART_TYPE_ROM_ONLY=
CART_TYPE_MBC1=$'\x01'
CART_TYPE_MBC1_SRAM=$'\x02'
CART_TYPE_MBC1_SRAM_BAT=$'\x03'
CART_TYPE_MBC2=$'\x05'
CART_TYPE_MBC2_BAT=$'\x06'
CART_TYPE_ROM_SRAM=$'\x08'
CART_TYPE_ROM_SRAM_BAT=$'\x09'
CART_TYPE_MMM01=$'\x0b'
CART_TYPE_MMM01_SRAM=$'\x0c'
CART_TYPE_MMM01_SRAM_BAT=$'\x0d'
CART_TYPE_MBC3_RTC_BAT=$'\x0f'
CART_TYPE_MBC3_RTC_SRAM_BAT=$'\x10'
CART_TYPE_MBC3=$'\x11'
CART_TYPE_MBC3_SRAM=$'\x12'
CART_TYPE_MBC3_SRAM_BAT=$'\x13'
CART_TYPE_MBC5=$'\x19'
CART_TYPE_MBC5_SRAM=$'\x1a'
CART_TYPE_MBC5_SRAM_BAT=$'\x1b'
CART_TYPE_MBC5_RUMBLE=$'\x1c'
CART_TYPE_MBC5_RUMBLE_SRAM=$'\x1d'
CART_TYPE_MBC5_RUMBLE_SRAM_BAT=$'\x1e'
CART_TYPE_MBC6=$'\x20'
CART_TYPE_MBC7=$'\x22'
CART_TYPE_CAMERA=$'\xfc'
CART_TYPE_TAMA5=$'\xfd'
CART_TYPE_HUC3=$'\xfe'
CART_TYPE_HUC1=$'\xff'

ROM_SIZE_32K=
ROM_SIZE_64K=$'\x01'
ROM_SIZE_128K=$'\x02'
ROM_SIZE_256K=$'\x03'
ROM_SIZE_512K=$'\x04'
ROM_SIZE_1M=$'\x05'
ROM_SIZE_2M=$'\x06'
ROM_SIZE_4M=$'\x07'
ROM_SIZE_8M=$'\x08'
ROM_SIZE_1M1=$'\x52'
ROM_SIZE_1M2=$'\x53'
ROM_SIZE_1M5=$'\x54'

RAM_SIZE_0=
RAM_SIZE_2K=$'\x01'
RAM_SIZE_8K=$'\x02'
RAM_SIZE_32K=$'\x03'
RAM_SIZE_128K=$'\x04'
RAM_SIZE_64K=$'\x05'

DEST_CODE_JAPAN=
DEST_CODE_OTHER=$'\x01'

OLD_LICENSE_DEFAULT=$'\x33'

function isint () { case ${1#[-+]} in ''|*[!0-9]*) return 1;; esac; }

function run () {
	gbdbg "$DEV" < <(
		if (($# == 0)); then
			set -- -
		fi
		used_stdin=
		while (($#)); do
			if [ "$1" == - ] && [ -z "$used_stdin" ]; then
				echo
				cat
				echo
				used_stdin=y
			else
				echo "$1"
			fi
			shift
		done
	)
}

function led () {
	local l=0
	local h=0
	if (($# == 1)) && isint "$1"; then
		run "wr $LED0 $(($1 & 0xff))" "wr $LED1 $((($1 >> 8) & 0xff))"
	elif (($# == 2)); then
		if [ "$1" == s ] && isint "$2"; then
			led 0xffff $((1 << $2))
		elif [ "$1" == r ] && isint "$2"; then
			led 0 $((1 << $2))
		else
			local val=$1
			local mask=$2
			if ! isint "$val" || ! isint "$mask"; then
				return 1
			fi
			if (((mask & 0xff) != 0 && (mask & 0xff) != 0xff)); then
				l=$(run "rd $LED0") || return $?
			fi
			if (((mask & 0xff00) != 0 && (mask & 0xff00) != 0xff00)); then
				h=$(run "rd $LED1") || return $?
			fi
			(( l = (l & ~(mask        & 0xff)) | (val        & 0xff & mask)        ))
			(( h = (h & ~((mask >> 8) & 0xff)) | ((val >> 8) & 0xff & (mask >> 8)) ))
			if (((mask & 0xff) != 0)); then
				if (((mask & 0xff00) != 0)); then
					run "wr $LED0 $l" "wr $LED0 $h"
				else
					run "wr $LED0 $l"
				fi
			elif (((mask & 0xff00) != 0)); then
				run "wr $LED1 $h"
			fi
		fi
	else
		return 1
	fi
}

function sysgen_led () {
	local l=0
	local h=0
	if (($# == 1)) && isint "$1"; then
		echo "
			ld a, $(($1 & 0xff))
			ld ($LED0), a
			ld a, $((($1 >> 8) & 0xff))
			ld ($LED1), a
		"
	elif (($# == 2)); then
		if [ "$1" == s ] && isint "$2"; then
			sysgen_led 0xffff $((1 << $2))
		elif [ "$1" == r ] && isint "$2"; then
			sysgen_led 0 $((1 << $2))
		else
			local val=$1
			local mask=$2
			if ! isint "$val" || ! isint "$mask"; then
				return 1
			fi
			if (((mask & 0xff) != 0 && (mask & 0xff) != 0xff)); then
				echo "
					ld a, ($LED0)
					and $((~(mask & 0xff)))
					or $((val & 0xff & mask))
					ld ($LED0), a
				"
			elif (((mask & 0xff) != 0)); then
				echo "
					ld a, $((val & 0xff))
					ld ($LED0), a
				"
			fi
			if (((mask & 0xff00) != 0 && (mask & 0xff00) != 0xff00)); then
				echo "
					ld a, ($LED1)
					and $((~((mask >> 8) & 0xff)))
					or $(((val >> 8) & 0xff & (mask >> 8)))
					ld ($LED1), a
				"
			elif (((mask & 0xff00) != 0)); then
				echo "
					ld a, $(((val >> 8) & 0xff))
					ld ($LED1), a
				"
			fi
		fi
	else
		return 1
	fi
}

function gen_set_atom () {
	if (($# != 1)) || ! isint "$1" || (($1 < 0 || $1 > 0xffffffff)); then
		return 1
	fi
	echo "
		wr $ATOM0 $(($1 & 0xff))
		wr $ATOM1 $((($1 >> 8) & 0xff))
		wr $ATOM2 $((($1 >> 16) & 0xff))
		wr $ATOM3 $((($1 >> 24) & 0xff))
	"
}

function sysgen_set_atom () {
	if (($# != 1)) || ! isint "$1" || (($1 < 0 || $1 > 0xffffffff)); then
		return 1
	fi
	echo "
		ld a, $(($1 & 0xff))
		ld ($ATOM0), a
		ld a, $((($1 >> 8) & 0xff))
		ld ($ATOM1), a
		ld a, $((($1 >> 16) & 0xff))
		ld ($ATOM2), a
		ld a, $((($1 >> 24) & 0xff))
		ld ($ATOM3), a
	"
}

function calc_hdr_check_sum () {
	local sum=$((0x19))
	while (($#)); do
		if ! isint "$1"; then
			return 1
		fi
		((sum += $1))
		shift
	done
	echo $((-sum & 0xff))
}

function gen_hdr () {
	# Args:
	#  1: game title
	#  2: game code
	#  3: CGB support code
	#  4: new license code
	#  5: SGB support code
	#  6: cartridge type
	#  7: ROM size
	#  8: RAM size
	#  9: destination code
	# 10: old license code
	# 11: ROM version

	local fld_len=( 11 4 1 2 1 1 1 1 1 1 1 )
	if (($# != ${#fld_len[*]})); then
		return 1
	fi

	local hdr=()
	local i
	for ((i = 0; i < ${#fld_len[*]}; i++)); do
		hdr+=( $({ echo -n "$1"; cat /dev/zero; } | od -vAn -tu1 -N${fld_len[i]}) )
		shift
	done

	local chksum
	chksum=$(calc_hdr_check_sum ${hdr[*]}) || return $?
	hdr+=( $chksum 0 0 )

	echo "
		# Place Nintendo logo
		buf a asm
			.db 0xCE 0xED 0x66 0x66 0xCC 0x0D 0x00 0x0B 0x03 0x73 0x00 0x83 0x00 0x0C 0x00 0x0D
			.db 0x00 0x08 0x11 0x1F 0x88 0x89 0x00 0x0E 0xDC 0xCC 0x6E 0xE6 0xDD 0xDD 0xD9 0x99
			.db 0xBB 0xBB 0x67 0x63 0x6E 0x0E 0xEC 0xCC 0xDD 0xDC 0x99 0x9F 0xBB 0xB9 0x33 0x3E
		end
		buf a store $((DUTRAM_START + 0x104))+48

		# Place header fields
		buf a asm
			.db ${hdr[*]}
		end
		buf a store $((DUTRAM_START + 0x134))+28
	"
}

function gen_default_hdr () {
	if (($# > 1)); then
		return 1
	fi
	local title=${1-TEST}
	gen_hdr "$title" TEST "$CGB_INCOMPATIBLE" ZZ "$SGB_INCOMPATIBLE" "$CART_TYPE_ROM_ONLY" \
	        "$ROM_SIZE_32K" "$RAM_SIZE_0" "$DEST_CODE_OTHER" "$OLD_LICENSE_DEFAULT" ""
}

function place_code () {
	if (($# != 1)) || ! isint "$1"; then
		return 1
	fi
	local adr=$1
	local dump
	dump=$(run 2>/dev/null < <(
		echo buf a asm
		cat
		echo end
		echo buf a store $adr
		echo buf a dump
	)) || return $?
	local elements=( $(echo "$dump" | sed -e '
		/:[^|]*|.*|/!d
		s/^[^|]*:\([^|]*\)|.*|[^|]*$/\1/
	') )
	echo ${#elements[*]}
}

function sys_code () {
	if (($# != 1)) || ! isint "$1"; then
		return 1
	fi
	local adr=$1
	place_code $((adr + SYSRAM_START)) < <(echo ".org $adr"; cat)
}

function dut_code () {
	if (($# != 1)) || ! isint "$1"; then
		return 1
	fi
	local adr=$1
	place_code $((adr + DUTRAM_START)) < <(echo ".org $adr"; cat)
}

function disable_all_breakpoints () {
	if (($#)); then
		return 1
	fi
	run < <(
		for ((i = 0; i < NUM_BREAKPOINTS; i++)); do
			echo "b $i 0xffff"
		done
	)
}

function init_dut_ram_for_boot () {
	if (($#)); then
		return 1
	fi

	local hdr
	hdr=$(gen_default_hdr) || return $?

	run >/dev/null 2>&1 < <(echo "
		$hdr

		# Place jump at DUT entry point
		buf a asm
			nop
			jr -2
		end
		buf a store $((DUTRAM_START + 0x100))+3
	")
}

function init () {
	if (($#)); then
		return 1
	fi

	run h                   || return $?
	disable_all_breakpoints || return $?
	run "x di"              || return $?
	led 0                   || return $?

	local atom
	atom=$(gen_set_atom 0) || return $?

	run >/dev/null 2>&1 < <(echo "
		# Disconnect routes to Port A Pin 0 trigger inputs to make sure DUT gets no clock
		$atom
		wr $PA_RESETTRIG 0xff
		wr $PA_SETTRIG   0xff

		# Set Port A Pin 0, 6 and 7 to high, others to low
		#  0: clk out
		#  1: serial out (serial in of Game Boy Link Port)
		#  2: serial clock (clock of Link Port)
		#  6: T1
		#  7: T2
		wr $PA_SET   0xc1
		wr $PA_RESET 0x3e

		# Disable Interrupts
		wr $IEN 0

		# Reset stack pointer
		set sp $((SYSRAM_START + SYSRAM_LEN))
	") || return $?

	sys_run $((0x100)) 2 < <(echo "
		; Zero out lower 256 bytes
		xor a
		ld hl, 0
	loop1:
		ld (hli), a
		bit 0, h
		jr z, loop1

		; Zero out DUT RAM
		ld hl, $DUTRAM_START
	loop2:
		ld (hli), a
		bit 5, h  ; expects end of DUT RAM to be 0x1fff
		jr z, loop2

		; Place jump for safety at the end of DUT RAM
		ld a, 0x18  ; JR instruction
		ldx ($((DUTRAM_END - 1))), a
		ld a, 0xfe  ; -2
		ldx ($DUTRAM_END), a
	") || return $?

	run >/dev/null 2>&1 < <(
		# Disconnect always one source
		echo "wr $ONES 0"

		# Reset counters
		for ((i = 0; i < NUM_COUNTERS; i++)); do
			echo wr ${COUNTER_SETIN[i]}  0xff
			echo wr ${COUNTER_SETOUT[i]} 0xff
			echo wr ${COUNTER_CTRL[i]}   $((COUNTER_CTRL_STOP | COUNTER_CTRL_RESET))
		done

		echo "
			# Reset DUT connector
			wr $DUT_CMP_OUT 0xff
			wr $DUT_CTRL    $((DUT_CTRL_RESET_DATA | DUT_CTRL_RESET_RESET))

			# Reset recorder
			wr $REC_CTRL $((REC_CTRL_SET_START | REC_CTRL_SET_STOP | REC_CTRL_SET_RECORD))
			wr $REC_CTRL $((REC_CTRL_STOP | REC_CTRL_SET_ADR))
			wr $REC_CFG  0

			# Reset interrupts flags
			wr $IFLAG 0
		"

		(
			# Make route 3 always one
			gen_set_always_one 3                || exit

			# Route 3 to Counter 0 COUNT
			gen_set_counter_count 0 3           || exit

			# Configure ~4.125 MHz on counter 0 compare regs 0&1
			gen_set_counter_comparator 0 0 7    || exit
			gen_set_counter_comparator 0 1 15   || exit

			# Use Route 0 to reset Port A Pin 0 when compare reg 0 triggers
			gen_set_counter_match 0 0 0         || exit
			gen_set_porta_reset   0   0         || exit

			# Use Route 1 to set Port A Pin 0 and reset counter 0 when compare reg 1 triggers
			gen_set_counter_match 0 1 1         || exit
			gen_set_counter_reset 0   1         || exit
			gen_set_porta_set     0   1         || exit

			gen_start_counter 0                 || exit
		) || { res=$?; echo; echo error $res; }
	)
}

function set_routes () {
	local gen; gen=$(gen_set_routes "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function checkargs_set_routes () {
	if (($# < 2)); then
		return 1
	fi
	local reg=$1
	local val=$2
	if ! isint "$reg" || ((reg < 0xff00 || reg > 0xffff)); then
		return 1
	fi
	if ! isint "$val" || ((val < 0 || val > 0xffff)); then
		return 1
	fi
	shift 2
	sum=0
	while (($#)); do
		if ! isint "$1"; then
			return 1
		fi
		((sum |= (1 << $1)))
		shift
	done
}

function gen_set_routes () {
	local reg=$1
	local val=$2
	local sum
	checkargs_set_routes "$@" || return $?
	gen_set_atom $sum         || return $?
	echo wr $reg $val
}

function sysgen_set_routes () {
	local reg=$1
	local val=$2
	local sum
	checkargs_set_routes "$@" || return $?
	sysgen_set_atom $sum      || return $?
	echo "
		ld a, $val
		ld ($reg), a
	"
}

function set_always_one        () { set_routes        $ONES 0 "$@"; }
function gen_set_always_one    () { gen_set_routes    $ONES 0 "$@"; }
function sysgen_set_always_one () { sysgen_set_routes $ONES 0 "$@"; }

function set_recorder_start         () { set_routes        $REC_CTRL $REC_CTRL_SET_START  "$@"; }
function gen_set_recorder_start     () { gen_set_routes    $REC_CTRL $REC_CTRL_SET_START  "$@"; }
function sysgen_set_recorder_start  () { sysgen_set_routes $REC_CTRL $REC_CTRL_SET_START  "$@"; }
function set_recorder_stop          () { set_routes        $REC_CTRL $REC_CTRL_SET_STOP   "$@"; }
function gen_set_recorder_stop      () { gen_set_routes    $REC_CTRL $REC_CTRL_SET_STOP   "$@"; }
function sysgen_set_recorder_stop   () { sysgen_set_routes $REC_CTRL $REC_CTRL_SET_STOP   "$@"; }
function set_recorder_record        () { set_routes        $REC_CTRL $REC_CTRL_SET_RECORD "$@"; }
function gen_set_recorder_record    () { gen_set_routes    $REC_CTRL $REC_CTRL_SET_RECORD "$@"; }
function sysgen_set_recorder_record () { sysgen_set_routes $REC_CTRL $REC_CTRL_SET_RECORD "$@"; }

function checkargs_recorder () {
	if (($# != 0)); then
		return 1
	fi
}

function recorder_start () {
	local gen; gen=$(gen_recorder_start "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_recorder_start () {
	checkargs_recorder "$@" || return $?
	echo "wr $REC_CTRL $REC_CTRL_START"
}

function sysgen_recorder_start () {
	checkargs_recorder "$@" || return $?
	echo "
		ld a, $REC_CTRL_START
		ld ($REC_CTRL), a
	"
}

function recorder_stop () {
	local gen; gen=$(gen_recorder_stop "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_recorder_stop () {
	checkargs_recorder "$@" || return $?
	echo "wr $REC_CTRL $REC_CTRL_STOP"
}

function sysgen_recorder_stop () {
	checkargs_recorder "$@" || return $?
	echo "
		ld a, $REC_CTRL_STOP
		ld ($REC_CTRL), a
	"
}

function record () {
	local gen; gen=$(gen_record "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_record () {
	checkargs_recorder "$@" || return $?
	echo "wr $REC_CTRL $REC_CTRL_RECORD"
}

function sysgen_record () {
	checkargs_recorder "$@" || return $?
	echo "
		ld a, $REC_CTRL_RECORD
		ld ($REC_CTRL), a
	"
}

function checkargs_recorder_adr () {
	if (($# != 1)) || ! isint "$1"; then
		return 1
	fi
}

function set_recorder_adr () {
	local gen; gen=$(gen_set_recorder_adr "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_set_recorder_adr () {
	checkargs_recorder_adr "$@" || return $?; local adr=$1
	gen_set_atom $adr || return $?
	echo "wr $REC_CTRL $REC_CTRL_SET_ADR"
}

function sysgen_set_recorder_adr () {
	checkargs_recorder_adr "$@" || return $?; local adr=$1
	sysgen_set_atom $adr || return $?
	echo "
		ld a, $REC_CTRL_SET_ADR
		ld ($REC_CTRL), a
	"
}

function checkargs_counter_routes () {
	if (($# < 1)) || ! isint "$1"; then
		return 1
	fi
}

function set_counter_count () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_COUNT "$@"
}

function gen_set_counter_count () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	gen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_COUNT "$@"
}

function sysgen_set_counter_count () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	sysgen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_COUNT "$@"
}

function set_counter_load () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_LOAD "$@"
}

function gen_set_counter_load () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	gen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_LOAD "$@"
}

function sysgen_set_counter_load () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	sysgen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_LOAD "$@"
}

function set_counter_reset () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_RESET "$@"
}

function gen_set_counter_reset () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	gen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_RESET "$@"
}

function sysgen_set_counter_reset () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	sysgen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_RESET "$@"
}

function set_counter_stop () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_STOP "$@"
}

function gen_set_counter_stop () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	gen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_STOP "$@"
}

function sysgen_set_counter_stop () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	sysgen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_STOP "$@"
}

function set_counter_start () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_START "$@"
}

function gen_set_counter_start () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	gen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_START "$@"
}

function sysgen_set_counter_start () {
	checkargs_counter_routes "$@" || return $?; local counter=$1; shift
	sysgen_set_routes ${COUNTER_SETIN[counter]} $COUNTER_SETIN_START "$@"
}

function checkargs_counter_comparator () {
	if (($# < 2)) || ! isint "$1" || ! isint "$2"; then
		return 1
	fi
}

function set_counter_match () {
	checkargs_counter_comparator "$@" || return $?; local counter=$1; local comparator=$2; shift 2
	set_routes ${COUNTER_SETOUT[counter]} $((1 << comparator)) "$@"
}

function gen_set_counter_match () {
	checkargs_counter_comparator "$@" || return $?; local counter=$1; local comparator=$2; shift 2
	gen_set_routes ${COUNTER_SETOUT[counter]} $((1 << comparator)) "$@"
}

function sysgen_set_counter_match () {
	checkargs_counter_comparator "$@" || return $?; local counter=$1; local comparator=$2; shift 2
	sysgen_set_routes ${COUNTER_SETOUT[counter]} $((1 << comparator)) "$@"
}

function checkargs_counter_comp_val () {
	if (($# != 3)) || ! isint "$1" || ! isint "$2" || ! isint "$3"; then
		return 1
	fi
}

function set_counter_comparator () {
	local gen; gen=$(gen_set_counter_comparator "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_set_counter_comparator () {
	checkargs_counter_comp_val "$@" || return $?; local counter=$1; local comparator=$2; local value=$3
	gen_set_atom $value || return $?
	echo "wr ${COUNTER_SETCMP[counter]} $((1 << comparator))"
}

function sysgen_set_counter_comparator () {
	checkargs_counter_comp_val "$@" || return $?; local counter=$1; local comparator=$2; local value=$3
	sysgen_set_atom $value || return $?
	echo "
		ld a, $((1 << comparator))
		ld (${COUNTER_SETCMP[counter]}), a
	"
}

function checkargs_counter_load () {
	if (($# != 2)) || ! isint "$1" || ! isint "$2"; then
		return 1
	fi
}

function set_counter_load () {
	local gen; gen=$(gen_set_counter_load "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_set_counter_load () {
	checkargs_counter_load "$@" || return $?; local counter=$1; local value=$2
	gen_set_atom $value || return $?
	echo "wr ${COUNTER_CTRL[counter]} $COUNTER_CTRL_SETLOAD"
}

function sysgen_set_counter_load () {
	checkargs_counter_load "$@" || return $?; local counter=$1; local value=$2
	sysgen_set_atom $value || return $?
	echo "
		ld a, $COUNTER_CTRL_SETLOAD
		ld (${COUNTER_CTRL[counter]}), a
	"
}

function checkargs_counter () {
	if (($# != 1)) || ! isint "$1"; then
		return 1
	fi
}

function count () {
	local gen; gen=$(gen_count "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_count () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "wr ${COUNTER_CTRL[counter]} $COUNTER_CTRL_COUNT"
}

function sysgen_count () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "
		ld a, $COUNTER_CTRL_COUNT
		ld (${COUNTER_CTRL[counter]}), a
	"
}

function reload_counter () {
	local gen; gen=$(gen_reload_counter "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_reload_counter () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "wr ${COUNTER_CTRL[counter]} $COUNTER_CTRL_LOAD"
}

function sysgen_reload_counter () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "
		ld a, $COUNTER_CTRL_LOAD
		ld (${COUNTER_CTRL[counter]}), a
	"
}

function reset_counter () {
	local gen; gen=$(gen_reset_counter "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_reset_counter () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "wr ${COUNTER_CTRL[counter]} $COUNTER_CTRL_RESET"
}

function sysgen_reset_counter () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "
		ld a, $COUNTER_CTRL_RESET
		ld (${COUNTER_CTRL[counter]}), a
	"
}

function stop_counter () {
	local gen; gen=$(gen_stop_counter "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_stop_counter () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "wr ${COUNTER_CTRL[counter]} $COUNTER_CTRL_STOP"
}

function sysgen_stop_counter () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "
		ld a, $COUNTER_CTRL_STOP
		ld (${COUNTER_CTRL[counter]}), a
	"
}

function start_counter () {
	local gen; gen=$(gen_start_counter "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_start_counter () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "wr ${COUNTER_CTRL[counter]} $COUNTER_CTRL_START"
}

function sysgen_start_counter () {
	checkargs_counter "$@" || return $?; local counter=$1
	echo "
		ld a, $COUNTER_CTRL_START
		ld (${COUNTER_CTRL[counter]}), a
	"
}

function checkargs_port_routes () {
	if (($# < 1)) || ! isint "$1"; then
		return 1
	fi
}

function set_porta_set () {
	checkargs_port_routes "$@" || return $?; local pin=$1; shift
	set_routes $PA_SETTRIG $((1 << pin)) "$@"
}

function gen_set_porta_set () {
	checkargs_port_routes "$@" || return $?; local pin=$1; shift
	gen_set_routes $PA_SETTRIG $((1 << pin)) "$@"
}

function sysgen_set_porta_set () {
	checkargs_port_routes "$@" || return $?; local pin=$1; shift
	sysgen_set_routes $PA_SETTRIG $((1 << pin)) "$@"
}

function set_porta_reset () {
	checkargs_port_routes "$@" || return $?; local pin=$1; shift
	set_routes $PA_RESETTRIG $((1 << pin)) "$@"
}

function gen_set_porta_reset () {
	checkargs_port_routes "$@" || return $?; local pin=$1; shift
	gen_set_routes $PA_RESETTRIG $((1 << pin)) "$@"
}

function sysgen_set_porta_reset () {
	checkargs_port_routes "$@" || return $?; local pin=$1; shift
	sysgen_set_routes $PA_RESETTRIG $((1 << pin)) "$@"
}

function checkargs_port () {
	if (($# != 1)) || ! isint "$1"; then
		return 1
	fi
}

function set_porta () {
	local gen; gen=$(gen_set_porta "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_set_porta () {
	checkargs_port "$@" || return $?; local mask=$1
	echo "wr $PA_SET $mask"
}

function sysgen_set_porta () {
	checkargs_port "$@" || return $?; local mask=$1
	echo "
		ld a, $mask
		ld ($PA_SET), a
	"
}

function reset_porta () {
	local gen; gen=$(gen_reset_porta "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_reset_porta () {
	checkargs_port "$@" || return $?; local mask=$1
	echo "wr $PA_RESET $mask"
}

function sysgen_reset_porta () {
	checkargs_port "$@" || return $?; local mask=$1
	echo "
		ld a, $mask
		ld ($PA_RESET), a
	"
}

function checkargs_dut_comp () {
	if (($# != 3)) || ! isint "$1" || ! isint "$2" || ! isint "$3"; then
		return 1
	fi
}

function set_dut_comparator () {
	local gen; gen=$(gen_set_dut_comparator "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_set_dut_comparator () {
	checkargs_dut_comp "$@" || return $?; local comparator=$1; local value=$2; local mask=$3
	gen_set_atom $value || return $?
	echo wr $DUT_CMP_IN $((1 << comparator))
	gen_set_atom $mask || return $?
	echo wr $DUT_CMP_IN $((1 << (comparator + 4)))
}

function sysgen_set_dut_comparator () {
	checkargs_dut_comp "$@" || return $?; local comparator=$1; local value=$2; local mask=$3
	sysgen_set_atom $value || return $?
	echo "
		ld a, $((1 << comparator))
		ld ($DUT_CMP_IN), a
	"
	sysgen_set_atom $mask || return $?
	echo "
		ld a, $((1 << (comparator + 4)))
		ld ($DUT_CMP_IN), a
	"
}

function checkargs_dut_comp_routes () {
	if (($# < 1)) || ! isint "$1"; then
		return 1
	fi
}

function set_dut_match () {
	checkargs_dut_comp_routes "$@" || return $?; local comparator=$1; shift
	set_routes $DUT_CMP_OUT $((1 << comparator)) "$@"
}

function gen_set_dut_match () {
	checkargs_dut_comp_routes "$@" || return $?; local comparator=$1; shift
	gen_set_routes $DUT_CMP_OUT $((1 << comparator)) "$@"
}

function sysgen_set_dut_match () {
	checkargs_dut_comp_routes "$@" || return $?; local comparator=$1; shift
	sysgen_set_routes $DUT_CMP_OUT $((1 << comparator)) "$@"
}

function set_dut_match_edge () {
	checkargs_dut_comp_routes "$@" || return $?; local comparator=$1; shift
	set_routes $DUT_CMP_OUT $((1 << (comparator + 4))) "$@"
}

function gen_set_dut_match_edge () {
	checkargs_dut_comp_routes "$@" || return $?; local comparator=$1; shift
	gen_set_routes $DUT_CMP_OUT $((1 << (comparator + 4))) "$@"
}

function sysgen_set_dut_match_edge () {
	checkargs_dut_comp_routes "$@" || return $?; local comparator=$1; shift
	sysgen_set_routes $DUT_CMP_OUT $((1 << (comparator + 4))) "$@"
}

function checkargs_dut_override () {
	if (($# == 1)) && ! isint "$1"; then
		return 1
	fi
	if (($# > 1)); then
		return 1
	fi
}

function dut_override_data () {
	local gen; gen=$(gen_dut_override_data "$@") || return $?
	run >/dev/null < <(echo "$gen")
}

function gen_dut_override_data () {
	checkargs_dut_override "$@" || return $?; local data=$1
	if (($#)); then
		echo "
			wr $DUT_DATA_OUT $data
			wr $DUT_CTRL $DUT_CTRL_SET_DATA
		"
	else
		echo "wr $DUT_CTRL $DUT_CTRL_RESET_DATA"
	fi
}

function sysgen_dut_override_data () {
	checkargs_dut_override "$@" || return $?; local data=$1
	if (($#)); then
		echo "
			ld a, $data
			ld ($DUT_DATA_OUT), a
			ld a, $DUT_CTRL_SET_DATA
			ld ($DUT_CTRL), a
		"
	else
		echo "
			ld a, $DUT_CTRL_RESET_DATA
			ld ($DUT_CTRL), a
		"
	fi
}

function wait_for_halt () {
	if (($# > 1)); then
		return 1
	fi
	local timeout=${1--1}
	if ! isint "$timeout"; then
		return 1
	fi
	while true; do
		if ((timeout > 0)); then
			((timeout--))
		fi
		local res=0
		local errmsg
		errmsg=$(run r 2>&1 >/dev/null) || res=$?
		if ((res == 6)); then
			if ((timeout != 0)); then
				sleep 1
				continue
			fi
			echo Timeout! >&2
			return $res
		elif ((res != 0)); then
			echo "$errmsg" >&2
			return $res
		fi
		break
	done
}

function set_breakpoint () {
	if (($# != 1 && $# != 2)); then
		return 1
	fi
	local idx=$1
	local adr=${2-$((0xffff))}
	if ! isint "$idx" || ! isint "$adr"; then
		return 1
	fi
	run "b $idx $adr"
}

function asmgen_string () {
	local str=$*
	local chars=( $(echo -n "$str" | od -vAn -tx1 | sed -e 's,\([0-9a-zA-Z][0-9a-zA-Z]\),0x\1,g') )
	echo .db ${chars[*]}
}

function sys_run () {
	if (($# != 1 && $# != 2)); then
		return 1
	fi

	local adr=$1
	local timeout=${2--1}
	if ! isint "$adr" || ! isint "$timeout"; then
		return 1
	fi

	local len
	len=$(sys_code $adr < <(cat; echo; echo nop; echo "jr -2")) || return $?

	run "set pc $adr" || return $?

	# Set breakpoint on "jr -2" instruction at the end
	set_breakpoint 0 $((adr + len - 2)) || return $?

	local res

	run c || { res=$?; set_breakpoint 0; return $res; }

	res=0
	wait_for_halt $timeout || res=$?
	run h
	set_breakpoint 0
	return $res
}

function dut_run () {
	local pos=0
	local adr=
	local timeout=
	local rec=
	local fast_rec=
	local ser_int=
	local ser_val=0
	while (($#)); do
		if isint "$1"; then
			if ((pos == 0)); then
				adr=$1
			elif ((pos == 1)); then
				timeout=$1
			elif ((pos == 2)); then
				ser_int=$1
			elif ((pos == 3)); then
				ser_val=$1
			else
				echo Too many arguments >&2
				return 1
			fi
			((++pos))
			shift
			continue
		fi
		case "$1" in
		-*)
			case "$1" in
			--rec)
				rec=y
				;;
			--rec-fast)
				rec=y
				fast_rec=y
				;;
			*)
				echo Unknown option >&2
				return 1
				;;
			esac
			;;
		*)
			echo Invalid argument >&2
			return 1
			;;
		esac
		shift
	done
	if ((pos < 1)); then
		echo Too few arguments >&2
		return 1
	fi

	local res=0
	local restore_routes=0

	stop_dut_clock || res=$?

	local len
	if ((!res)); then
		len=$(dut_code $adr < <(cat; echo; echo nop; echo "jr -2")) || res=$?
	fi

	local scode
	scode=$(
		if [ -n "$rec" ]; then
			echo "
				; Make sure trigger inputs of recorder are disconnected and recorder is stopped at adr 0
				$(sysgen_set_atom 0)
				ld a, $((REC_CTRL_SET_START | REC_CTRL_SET_STOP | REC_CTRL_SET_RECORD))
				ld ($REC_CTRL), a
				ld a, $((REC_CTRL_STOP | REC_CTRL_SET_ADR))
				ld ($REC_CTRL), a
			"

			# Configure recorder triggers
			if [ -n "$fast_rec" ]; then
				sysgen_set_recorder_record 3
				sysgen_set_recorder_stop   2
			else
				sysgen_set_recorder_record 0 1
				sysgen_set_recorder_stop   2
			fi
		fi

		echo "
			; Only output NOPs on data lines when DUT reads from cartridge
			$(sysgen_dut_override_data 0)

			; Clock "manually" for seven memory cycles, so CPU finishes current instruction and read NOPs
			ld b, $((7 * 4))
		clk_loop:
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			dec b
			jr nz, clk_loop

			; Clock "manually" until PHI has rising edge, so we know that we are at the beginning of a memory cycle
		phi1:
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			ld a, ($DUT_IN)
			bit $DUT_IN_PHI_POS, a
			jr nz, phi1
		phi0:
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			ld a, ($DUT_IN)
			bit $DUT_IN_PHI_POS, a
			jr z, phi0

			; Output JP instruction to DUT
			$(sysgen_dut_override_data $((0xc3)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))

			; Output LSB of address to DUT
			$(sysgen_dut_override_data $((adr & 0xff)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))

			; Output MSB of address to DUT
			$(sysgen_dut_override_data $((adr >> 8)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))

			; Stop overriding DUT data lines
			$(sysgen_dut_override_data)

			; Finish the jump.
			; We have to make sure the jump is finished before setting up the comparator, just in case
			; the PC is currently at our "jr -2" instruction at the end. In that rare case, we would immediately
			; get triggered by the comparator and think we are already finished executing the code, when in fact we
			; haven't even started.
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))
			$(sysgen_reset_porta $((0x01)))
			$(sysgen_set_porta   $((0x01)))

			; Trigger when DUT reads address of the "jr -2" instruction we've placed at the end
			$(sysgen_set_dut_comparator 0 $((
				(adr + len - 2) << DUT_BIT_ADR_SHIFT |
				DUT_BIT_CS_ROM |
				DUT_BIT_DATA_OUT_DIR |
				DUT_BIT_RD
			)) $((
				DUT_BIT_ADR_MASK |
				DUT_BIT_CS_ROM |
				DUT_BIT_DATA_OUT_DIR |
				DUT_BIT_CS_RAM |
				DUT_BIT_RD |
				DUT_BIT_WR |
				DUT_BIT_RST
			)))

			; Route 2 carries DUT bus compare match to counter 0 STOP and RESET (and maybe recorder STOP)
			$(sysgen_set_dut_match     0   2)
			$(sysgen_set_counter_stop  0   2)
			$(sysgen_set_counter_reset 0 1 2)

			; Clear interrupt flags
			xor a
			ld ($IFLAG), a
		"

		# Start recording
		if [ -n "$rec" ]; then
			if [ -n "$fast_rec" ]; then
				sysgen_set_recorder_start 0 1
			else
				sysgen_recorder_start
			fi
		fi

		if [ -n "$ser_int" ]; then
			# Reset Link Port
			sysgen_reset_porta 6

			while ((ser_int > 0)); do
				sysgen_record
				sysgen_reset_porta 1
				ser_int=$((ser_int - 1))
				if ((!ser_int)); then
					break
				fi
				sysgen_record
				sysgen_set_porta 1
				ser_int=$((ser_int - 1))
			done

			# Shift one byte into the Game Boy's Link Port
			for ((i = 0; i < 8; i++)); do
				if ((ser_val & $((0x80 >> i)))); then
					sysgen_set_porta 2
				else
					sysgen_reset_porta 2
				fi
				echo nop
				echo nop
				sysgen_set_porta 4
				echo nop
				echo nop
				sysgen_reset_porta 4
			done
			echo nop
			echo nop
			sysgen_reset_porta 2
		fi

		echo "
			; Start Counter 0 again
			$(sysgen_start_counter 0)

			; Wait for match
			ld hl, $IFLAG
		loop:
			ld a, (hl)
			bit 2, a
			jr z, loop

			; Disconnect route 2 on both ends
			$(sysgen_set_dut_match     0)
			$(sysgen_set_counter_stop  0)
			$(sysgen_set_counter_reset 0 1)

			; Start Counter 0 again
			$(sysgen_start_counter 0)
		"

		# Disconnect recorder triggers and make sure recording actually stopped
		if [ -n "$rec" ]; then
			sysgen_set_recorder_start
			sysgen_recorder_stop
			sysgen_set_recorder_record
			sysgen_set_recorder_stop
		fi
	)

	if ((!res)); then
		restore_routes=1
		sys_run $((0x100)) $timeout < <(echo "$scode") || res=$?
	fi

	# Make sure DUT is getting clocked again, even in the case of an error
	if ((res)); then
		if ((restore_routes)); then
			sys_run $((0x100)) 2 < <(
				# Disconnect route 2 on both ends
				sysgen_set_dut_match     0
				sysgen_set_counter_stop  0
				sysgen_set_counter_reset 0 1

				# Start Counter 0 again
				sysgen_start_counter 0

				# Disconnect recorder triggers and stop recording
				if [ -n "$rec" ]; then
					sysgen_set_recorder_start
					sysgen_recorder_stop
					sysgen_set_recorder_record
					sysgen_set_recorder_stop
				fi
			)
		else
			start_dut_clock
		fi
	fi

	return $res
}

function start_dut_clock () {
	start_counter 0
}

function stop_dut_clock () {
	stop_counter 0
	reset_counter 0
}

function reset_dut () {
	run "wr $DUT_CTRL $DUT_CTRL_SET_RESET" "wr $DUT_CTRL $DUT_CTRL_RESET_RESET"
}

function boot_dut () {
	stop_dut_clock        || return $?
	init_dut_ram_for_boot || return $?
	reset_dut             || return $?

	sys_run $((0x100)) 7 < <(echo "
		; Trigger when DUT reads address 0x101
		$(sysgen_set_dut_comparator 0 $((
			0x101 << DUT_BIT_ADR_SHIFT |
			DUT_BIT_CS_ROM |
			DUT_BIT_DATA_OUT_DIR |
			DUT_BIT_RD
		)) $((
			DUT_BIT_ADR_MASK |
			DUT_BIT_CS_ROM |
			DUT_BIT_DATA_OUT_DIR |
			DUT_BIT_CS_RAM |
			DUT_BIT_RD |
			DUT_BIT_WR |
			DUT_BIT_RST
		)))

		; Route 2 carries DUT bus compare match to counter 0 STOP and RESET
		$(sysgen_set_dut_match     0   2)
		$(sysgen_set_counter_stop  0   2)
		$(sysgen_set_counter_reset 0 1 2)

		; Clear interrupt flags
		xor a
		ld ($IFLAG), a

		; Start Counter 0 again
		$(sysgen_start_counter 0)

		; Wait for match
		ld hl, $IFLAG
	loop:
		ld a, (hl)
		bit 2, a
		jr z, loop

		; Disconnect route 2 on both ends
		$(sysgen_set_dut_match     0)
		$(sysgen_set_counter_stop  0)
		$(sysgen_set_counter_reset 0 1)

		; Start Counter 0 again
		$(sysgen_start_counter 0)
	")
}

function boot_dut_unlocked () {
	stop_dut_clock        || return $?
	init_dut_ram_for_boot || return $?

	# Place loop at 0x200 and some NOPs before that, where the DUT arrives after overclocking
	dut_code $((0x1fe)) >/dev/null < <(echo "
		nop
		nop
		jr -2
	") || return $?

	reset_dut || return $?

	sys_run $((0x100)) 7 < <(echo "
		; Configure 33 MHz on counter 0 compare regs 2&3&4
		$(sysgen_set_counter_comparator 0 2 18)
		$(sysgen_set_counter_comparator 0 3 19)
		$(sysgen_set_counter_comparator 0 4 20)

		; Compare reg 3 also triggers reset Port A via Route 0
		$(sysgen_set_counter_match 0 3 0)

		; Compare reg 4 also triggers set Port A and reset counter 0 via Route 1
		$(sysgen_set_counter_match 0 4 1)

		; Trigger when DUT reads address 0x014c
		$(sysgen_set_dut_comparator 0 $((
			0x14c << DUT_BIT_ADR_SHIFT |
			DUT_BIT_CS_ROM |
			DUT_BIT_DATA_OUT_DIR |
			DUT_BIT_RD
		)) $((
			DUT_BIT_ADR_MASK |
			DUT_BIT_CS_ROM |
			DUT_BIT_DATA_OUT_DIR |
			DUT_BIT_CS_RAM |
			DUT_BIT_RD |
			DUT_BIT_WR |
			DUT_BIT_RST
		)))

		; Route 2 carries DUT bus compare match to counter 0 STOP
		$(sysgen_set_dut_match    0 2)
		$(sysgen_set_counter_stop 0 2)

		; Clear interrupt flags
		xor a
		ld ($IFLAG), a

		; Start Counter 0
		$(sysgen_start_counter 0)

		; Wait for match
		ld hl, $IFLAG
	loop:
		ld a, (hl)
		bit 2, a
		jr z, loop

		; If there is no delay in the comparator signal, then the clock
		; output line (bit 0 in 0xff40) should be high at this point.
		; But with an 1 tick delay it should be low already. In this case
		; the first resetting of the clock line during "manually" clocking
		; below would be unnecessary, but it doesn't hurt either.

		; Disconnect route 2 on both ends
		$(sysgen_set_dut_match 0)
		$(sysgen_set_counter_stop 0)

		; Load 17 to counter 0
		$(sysgen_set_counter_load 0 17)
		$(sysgen_reload_counter 0)

		; Connect Route 2 to compare reg 2
		$(sysgen_set_counter_match 0 2 2)

		; Use Route 1&2 to set Port A Pin 0
		$(sysgen_set_porta_set 0 1 2)

		; Clock "manually" until right spot
		$(
			sysgen_reset_porta $((0x01))
			for ((i = 0; i < 6; i++)); do
				sysgen_set_porta   $((0x01))
				sysgen_reset_porta $((0x01))
			done
		)

		; Clear interrupt flags
		xor a
		ld ($IFLAG), a

		; Start Counter 0 again
		$(sysgen_start_counter 0)

		; Wait for overclock event
		ld hl, $IFLAG
	loop2:
		ld a, (hl)
		bit 1, a
		jr z, loop2

		; Cleanup counter 0 and Port A
		$(sysgen_set_porta_set 0 1)
		$(sysgen_set_counter_match 0 2)
		$(sysgen_set_counter_match 0 3)
		$(sysgen_set_counter_match 0 4)

		; Trigger when DUT reads address 0x200
		$(sysgen_set_dut_comparator 0 $((
			0x200 << DUT_BIT_ADR_SHIFT |
			DUT_BIT_CS_ROM |
			DUT_BIT_DATA_OUT_DIR |
			DUT_BIT_RD
		)) $((
			DUT_BIT_ADR_MASK |
			DUT_BIT_CS_ROM |
			DUT_BIT_DATA_OUT_DIR |
			DUT_BIT_CS_RAM |
			DUT_BIT_RD |
			DUT_BIT_WR |
			DUT_BIT_RST
		)))

		; Clear interrupt flags
		xor a
		ld ($IFLAG), a

		; Route 2 carries DUT bus compare match to counter 0 STOP and RESET
		$(sysgen_set_counter_stop  0   2)
		$(sysgen_set_counter_reset 0 1 2)
		$(sysgen_set_dut_match     0   2)

		; Wait for match
		ld hl, $IFLAG
	loop3:
		ld a, (hl)
		bit 2, a
		jr z, loop3

		; Disconnect route 2 on both ends
		$(sysgen_set_dut_match     0)
		$(sysgen_set_counter_stop  0)
		$(sysgen_set_counter_reset 0 1)

		; Start Counter 0 again
		$(sysgen_start_counter 0)
	")
}

function checkargs_dump () {
	local pos=0
	adr=
	len=256
	mode=hex
	while (($#)); do
		case "$1" in
		-*)
			case "$1" in
			--hex)
				mode=hex
				;;
			--bin)
				mode=binary
				;;
			--dis)
				mode=disassembly
				;;
			*)
				echo Unknown option >&2
				return 1
				;;
			esac
			;;
		*)
			if ((pos == 0)); then
				adr=$1
			elif ((pos == 1)); then
				len=$1
			else
				echo Too many arguments >&2
				return 1
			fi
			((pos++))
			;;
		esac
		shift
	done
	if ((pos < 1)); then
		echo Too few arguments >&2
		return 1
	fi
	if ! isint "$adr"; then
		echo Address not a number >&2
		return 1
	fi
	if ! isint "$len"; then
		echo Length not a number >&2
		return 1
	fi
	if ((adr < 0 || adr > 0xffff)); then
		echo Address out of range >&2
		return 1
	fi
	if ((pos < 2 && adr + len > 0x10000)); then
		len=$((0x10000 - adr))
	fi
	if ((len < 1 || len > 0x10000)); then
		echo Length out of range >&2
		return 1
	fi
	if ((adr + len > 0x10000)); then
		echo Address + Length out of range >&2
		return 1
	fi
}

function sys_dump () {
	local adr
	local len
	local mode
	checkargs_dump "$@" || return $?
	if [ "$mode" == binary ]; then
		local l
		local bs=256
		local dump
		local elements=()
		while ((len)); do
			l=$len
			if ((l > bs)); then
				l=$bs
			fi
			dump=$(run "dump $adr+$l" 2>/dev/null) || return $?
			elements=( $(echo "$dump" | sed -e '
				/:[^|]*|.*|/!d
				s/^[^|]*:\([^|]*\)|.*|[^|]*$/\1/
			') )
			echo "${elements[*]}" | xxd -r -ps
			len=$((len - l))
			adr=$((adr + l))
		done
	elif [ "$mode" == disassembly ]; then
		run "dis $adr+$len" 2>/dev/null
	else
		run "dump $adr+$len" 2>/dev/null
	fi
}

function dut_dump () {
	local adr
	local len
	local mode
	checkargs_dump "$@" || return $?
	while ((len)); do
		local l=$len
		if ((l > DUTRAM_LEN - 16)); then
			l=$((DUTRAM_LEN - 16))
		fi
		local last=$((l == len))
		dut_run $((0x200)) 3 < <(echo "
			ld hl, 0xa000
			ld bc, $adr
			ld de, $((l + 2)) ; Grab two more bytes for disassembler
		loop:
			ld a, (bc)
			ld (hli), a
			inc bc
			dec de
			ld a, d
			or e
			jr nz, loop
		") || return $?
		if [ "$mode" == hex ]; then
			local dump
			local line
			dump=$(sys_dump --hex $DUTRAM_START $l) || return $?
			while read -r line; do
				if ! ((last)) && [ -z "$(echo "$line" | sed -e '/^ *[0-9a-fA-F]\+ *: *| *| *$/d')" ]; then
					continue
				fi
				local a
				local r
				a=$(($(echo "$line" | sed -e 's,^ *\([0-9a-fA-F]\+\) *:.*$,0x\1,')))
				r=$(echo "$line" | sed -e 's,^ *[0-9a-fA-F]\+ *\(:.*\)$,\1,')
				a=$((a - DUTRAM_START + adr))
				printf "%04x%s\n" $a "$r"
			done < <(echo "$dump")
		elif [ "$mode" == disassembly ]; then
			local dump
			local line
			local dis_len
			dump=$(sys_dump --dis $DUTRAM_START $l) || return $?
			while read -r line; do
				local a
				local r
				a=$(($(echo "$line" | sed -e 's,^ *\([0-9a-fA-F]\+\) *:.*$,0x\1,')))
				r=$(echo "$line" | sed -e 's,^ *[0-9a-fA-F]\+ *\(:.*\)$,\1,')

				# Disassembler may disassemble up to two bytes more than expected, iff last instruction has
				# multiple bytes: Count them.
				l=$((a + $(echo "$r" | sed -e 's,^:\(..........\).*$,\1,' | wc -w) - DUTRAM_START))

				a=$((a - DUTRAM_START + adr))
				if [ -z "$(echo "$r" | sed -e '/^:.......... *[Jj][Rr] \+.* \+; \+\$[0-9a-fA-F]\+ *$/d')" ]; then
					local j=$(($(echo "$r" | sed -e 's,^:.......... *[Jj][Rr] \+.* \+; \+\$\([0-9a-fA-F]\+\) *$,0x\1,')))
					r=$(echo "$r" | sed -e 's,^\(:.......... *[Jj][Rr] \+.* \+; \+\$\)[0-9a-fA-F]\+ *$,\1,')
					j=$((j - DUTRAM_START + adr))
					printf "  %04x%s%04x\n" $a "$r" $j
				else
					printf "  %04x%s\n" $a "$r"
				fi
			done < <(echo "$dump")
			if ((l > len)); then
				l=$len
			fi
		else
			sys_dump --bin $DUTRAM_START $l || return $?
		fi
		len=$((len - l))
		adr=$((adr + l))
	done
}

function read_binary_uint32 () {
	local v
	v=$(od -A n -N 4 -t u4) || return $?
	v=$(echo $v) # Remove leading space
	isint "$v" || return $?
	echo $v
}

function read_decimal_uint32 () {
	local v
	read v || return $?
	isint "$v" || return $?
	echo $v
}

function read_uint32 () {
	if [ "$1" == --bin ]; then
		read_binary_uint32
	elif (($# == 0)); then
		read_decimal_uint32
	else
		return 1
	fi
}

function dump_vcd_values () {
	local v=$1
	local pv=$2
	if (((v & 0xffff) != (pv & 0xffff))); then
		echo -n b
		echo -n $(((v & 0x8000) == 0))
		echo -n $(((v & 0x4000) != 0))
		echo -n $(((v & 0x2000) != 0))
		echo -n $(((v & 0x1000) != 0))
		echo -n $(((v & 0x0800) != 0))
		echo -n $(((v & 0x0400) != 0))
		echo -n $(((v & 0x0200) != 0))
		echo -n $(((v & 0x0100) != 0))
		echo -n $(((v & 0x0080) != 0))
		echo -n $(((v & 0x0040) != 0))
		echo -n $(((v & 0x0020) != 0))
		echo -n $(((v & 0x0010) != 0))
		echo -n $(((v & 0x0008) != 0))
		echo -n $(((v & 0x0004) != 0))
		echo -n $(((v & 0x0002) != 0))
		echo -n $(((v & 0x0001) != 0))
		echo ' a'
	fi
	v=$((v >> 16))
	pv=$((pv >> 16))
	if (((v & 0xff) != (pv & 0xff))); then
		echo -n b
		echo -n $(((v & 0x80) != 0))
		echo -n $(((v & 0x40) != 0))
		echo -n $(((v & 0x20) != 0))
		echo -n $(((v & 0x10) != 0))
		echo -n $(((v & 0x08) != 0))
		echo -n $(((v & 0x04) != 0))
		echo -n $(((v & 0x02) != 0))
		echo -n $(((v & 0x01) != 0))
		echo ' d'
	fi
	v=$((v >> 8))
	pv=$((pv >> 8))
	if (((v & 0x01) != (pv & 0x01))); then
		echo $(((v & 0x01) != 0))o
	fi
	if (((v & 0x02) != (pv & 0x02))); then
		echo $(((v & 0x02) == 0))c
	fi
	if (((v & 0x04) != (pv & 0x04))); then
		echo $(((v & 0x04) == 0))r
	fi
	if (((v & 0x08) != (pv & 0x08))); then
		echo $(((v & 0x08) == 0))w
	fi
	if (((v & 0x10) != (pv & 0x10))); then
		echo $(((v & 0x10) != 0))p
	fi
	if (((v & 0x20) != (pv & 0x20))); then
		echo $(((v & 0x20) == 0))t
	fi
	if (((v & 0x40) != (pv & 0x40))); then
		echo $(((v & 0x40) != 0))k
	fi
}

function generate_vcd () {
	local fast=
	local bin=
	while (($#)); do
		case "$1" in
		--fast)
			fast=y
			;;
		--bin)
			bin=--bin
			;;
		*)
			echo Unknown option >&2
			return 1
			;;
		esac
		shift
	done

	local step=1190  # time step for 8.4 MHz in 100 ps units
	if [ -n "$fast" ]; then
		step=152  # time step for 66 MHz in 100 ps units
	fi

	local v
	local pv
	local t=0

	echo '$date'
	echo -n $'\t'
	date
	echo '$end'
	echo '$version'
	echo $'\tShiva'
	echo '$end'
	echo '$timescale'
	echo $'\t100ps'
	echo '$end'
	echo '$scope module dut_bus $end'
	echo '$var wire 16 a a [15:0] $end'
	echo '$var wire 8 d d [7:0] $end'
	echo '$var wire 1 o dir $end'
	echo '$var wire 1 c ~cs $end'
	echo '$var wire 1 r ~rd $end'
	echo '$var wire 1 w ~wr $end'
	echo '$var wire 1 p phi $end'
	echo '$var wire 1 t ~rst $end'
	echo '$var wire 1 k xi $end'
	echo '$upscope $end'
	echo '$enddefinitions $end'

	echo '$dumpvars'
	v=$(read_uint32 $bin)
	dump_vcd_values $v $((v ^ 0x7fffffff))
	pv=$v
	echo '$end'

	while v=$(read_uint32 $bin); do
		t=$((t + step))
		if ((v == pv)); then
			continue
		fi
		echo '#'$t
		dump_vcd_values $v $pv
		pv=$v
	done
}

function rec_dump () {
	if (($# > 1)); then
		echo Too many arguments >&2
		return 1
	fi

	local pos=${1-0}
	if ! isint "$pos"; then
		echo Pos not an integer >&2
		return 1
	fi

	local v
	local l
	local end_of_rec=

	if ((pos * 4 >= RECRAM_LEN)); then
		echo Pos too large >&2
		return 1
	fi

	while [ -z "$end_of_rec" ]; do
		if ((pos * 4 >= RECRAM_LEN)); then
			break
		fi

		l=$((RECRAM_LEN / 4 - pos))
		if ((l > 64)); then
			l=64
		fi

		while v=$(read_binary_uint32); do
			echo $v

			if ((v & 0x80000000)); then
				end_of_rec=y
				break
			fi
		done < <(sys_dump $((RECRAM_START + pos * 4)) $((l * 4)) --bin)

		pos=$((pos + l))
	done
}

function capture () {
	local pos=0
	local fast=
	local rec=--rec
	local gui=
	local adr=
	local timeout=
	local ser_int=
	local ser_val=
	while (($#)); do
		if isint "$1"; then
			if ((pos == 0)); then
				adr=$1
			elif ((pos == 1)); then
				timeout=$1
			elif ((pos == 2)); then
				ser_int=$1
			elif ((pos == 3)); then
				ser_val=$1
			else
				echo Too many arguments >&2
				return 1
			fi
			((++pos))
			shift
			continue
		fi
		case "$1" in
		--fast)
			fast=--fast
			rec=--rec-fast
			;;
		--gui)
			gui=y
			;;
		--)
			shift
			break
			;;
		*)
			break
			;;
		esac
		shift
	done

	if [ -z "$adr" ]; then
		adr=$((0x200))
	fi

	dut_run $adr $timeout $ser_int $ser_val $rec < <(
		if (($# == 0)); then
			set -- -
		fi
		used_stdin=
		while (($#)); do
			if [ "$1" == - ] && [ -z "$used_stdin" ]; then
				echo
				cat
				echo
				used_stdin=y
			else
				echo "$1"
			fi
			shift
		done
	) || return $?

	if [ -n "$gui" ]; then
		local tempfile=
		local ret=0
		tempfile=$(mktemp)
		rec_dump > >(generate_vcd $fast >"$tempfile") || ret=$?
		if ((ret)); then
			rm "$tempfile"
			return $ret
		fi
		gtkwave "$tempfile" "$SHIVA_DIR/dut_bus.gtkw" || ret=$?
		rm "$tempfile"
		return $ret
	else
		rec_dump > >(generate_vcd $fast)
	fi
}
